<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Da Cloud Config Center — Admin Console (Demo)</title>
  <meta name="description" content="DCCC — Admin demo console for Da Cloud Config Center. Enter base API URL, Read Token and Write Token to manage configs." />
  <!-- Tailwind CDN (for demo pages this is fine) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small custom tweaks */
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }
    .table-scroll { max-height: 56vh; overflow: auto; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-white border-b">
      <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between gap-4">
        <div class="flex items-center gap-3">
          <div class="rounded-lg bg-indigo-600 text-white p-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v4a1 1 0 001 1h3l3 4v-9l3-2 3 2v9l3-4h3a1 1 0 001-1V7a3 3 0 00-3-3h-1a3 3 0 00-2.12.88L12 8 8.12 4.88A3 3 0 006 4H5a3 3 0 00-2 3z" />
            </svg>
          </div>
          <div>
            <h1 class="text-lg font-semibold">Da Cloud Config Center <span class="text-indigo-600">— Admin Console (Demo)</span></h1>
            <p class="text-sm text-gray-500">Live demo — connect with your DCCC Worker using Read/Write tokens (not stored).</p>
          </div>
        </div>

        <div class="flex-1 max-w-2xl">
          <div class="grid grid-cols-3 gap-3">
            <input id="baseUrl" type="url" class="border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-300" placeholder="API Base URL" value="https://dccc.dagedemo.workers.dev/" />
            <input id="readToken" type="password" class="border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-300" placeholder="Read Token (required for read ops)" />
            <input id="writeToken" type="password" class="border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-300" placeholder="Write Token (required for write ops)" />
          </div>
        </div>

        <div class="flex items-center gap-2">
          <button id="connectBtn" class="bg-indigo-600 text-white px-4 py-2 rounded shadow hover:bg-indigo-700">Connect</button>
          <button id="clearBtn" class="border px-3 py-2 rounded text-sm text-gray-700">Clear</button>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="flex-1 max-w-6xl mx-auto px-4 py-6 w-full">
      <!-- Connect status -->
      <div id="status" class="mb-4 flex items-center justify-between gap-4">
        <div>
          <span id="connBadge" class="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm bg-yellow-100 text-yellow-800">Not connected</span>
          <span id="lastMsg" class="ml-3 text-sm text-gray-500"></span>
        </div>
        <div class="flex items-center gap-2">
          <button id="refreshBtn" class="hidden border px-3 py-1 rounded text-sm">Refresh</button>
          <button id="addBtn" class="hidden bg-green-600 text-white px-3 py-1 rounded text-sm">+ Add</button>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
        <!-- Controls -->
        <section class="md:col-span-1 bg-white border rounded p-4">
          <h2 class="text-sm font-medium mb-3">Scope</h2>
          <label class="block text-xs text-gray-600 mb-1">Service</label>
          <input id="serviceInput" class="w-full border rounded px-2 py-2 mb-3" placeholder="e.g. my-service" />
          <label class="block text-xs text-gray-600 mb-1">Instance</label>
          <input id="instanceInput" class="w-full border rounded px-2 py-2 mb-3" placeholder="e.g. prod | staging | instance-1" />
          <div class="flex gap-2">
            <button id="loadBtn" class="w-full bg-indigo-600 text-white px-3 py-2 rounded">Load Configs</button>
            <button id="clearScopeBtn" class="w-full border px-3 py-2 rounded">Clear</button>
          </div>

          <hr class="my-4" />

          <p class="text-xs text-gray-500">Endpoints used (demo):</p>
          <ul class="text-xs text-gray-600 mt-2 space-y-1">
            <li><span class="mono">GET /list?service=&instance=</span></li>
            <li><span class="mono">GET /get?service=&instance=&key=</span></li>
            <li><span class="mono">POST /set</span></li>
            <li><span class="mono">DELETE /delete?service=&instance=&key=</span></li>
          </ul>
        </section>

        <!-- Table -->
        <section class="md:col-span-3 bg-white border rounded p-4">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-sm font-medium">Configurations</h2>
            <div class="flex items-center gap-2">
              <input id="searchInput" class="border rounded px-2 py-1 text-sm" placeholder="Filter by key" />
              <button id="downloadBtn" class="border px-3 py-1 rounded text-sm">Export JSON</button>
            </div>
          </div>

          <div class="table-scroll border rounded">
            <table class="min-w-full divide-y">
              <thead class="bg-gray-50 sticky top-0">
                <tr class="text-left text-xs text-gray-600">
                  <th class="px-4 py-2 w-1/3">Key</th>
                  <th class="px-4 py-2">Value (preview)</th>
                  <th class="px-4 py-2 w-40">Actions</th>
                </tr>
              </thead>
              <tbody id="configsTbody" class="divide-y text-sm">
                <!-- rows injected here -->
                <tr id="emptyRow" class="text-gray-500"><td class="px-4 py-6" colspan="3">No configs loaded. Set scope & click <strong>Load Configs</strong>.</td></tr>
              </tbody>
            </table>
          </div>

          <div class="mt-4 text-xs text-gray-500">Tip: click <em>View</em> to see full value and edit. Use <em>+ Add</em> to create a new key.</div>
        </section>
      </div>
    </main>

    <footer class="bg-white border-t">
      <div class="max-w-6xl mx-auto px-4 py-4 text-xs text-gray-500">
        Powered by Da Cloud Config Center — dage.party
      </div>
    </footer>
  </div>

  <!-- Modal template (hidden) -->
  <div id="modalRoot"></div>

  <script>
    // ---------- State ----------
    let state = {
      baseUrl: document.getElementById('baseUrl').value.trim(),
      readToken: '',
      writeToken: '',
      connected: false,
      service: '',
      instance: '',
      configs: [], // array of { key, value }
    };

    // ---------- DOM refs ----------
    const connectBtn = document.getElementById('connectBtn');
    const clearBtn = document.getElementById('clearBtn');
    const connBadge = document.getElementById('connBadge');
    const lastMsg = document.getElementById('lastMsg');
    const refreshBtn = document.getElementById('refreshBtn');
    const addBtn = document.getElementById('addBtn');
    const loadBtn = document.getElementById('loadBtn');
    const clearScopeBtn = document.getElementById('clearScopeBtn');
    const serviceInput = document.getElementById('serviceInput');
    const instanceInput = document.getElementById('instanceInput');
    const configsTbody = document.getElementById('configsTbody');
    const emptyRow = document.getElementById('emptyRow');
    const searchInput = document.getElementById('searchInput');
    const downloadBtn = document.getElementById('downloadBtn');

    // initial UI binding
    document.getElementById('readToken').addEventListener('input', e => state.readToken = e.target.value);
    document.getElementById('writeToken').addEventListener('input', e => state.writeToken = e.target.value);
    document.getElementById('baseUrl').addEventListener('input', e => state.baseUrl = e.target.value.trim());

    connectBtn.addEventListener('click', onConnect);
    clearBtn.addEventListener('click', onClearAll);
    refreshBtn.addEventListener('click', loadConfigs);
    addBtn.addEventListener('click', () => openEditModal({ isNew: true }));
    loadBtn.addEventListener('click', () => {
      state.service = serviceInput.value.trim();
      state.instance = instanceInput.value.trim();
      loadConfigs();
    });
    clearScopeBtn.addEventListener('click', () => { serviceInput.value=''; instanceInput.value=''; state.service=''; state.instance=''; renderConfigs([]); });
    searchInput.addEventListener('input', renderConfigsFiltered);
    downloadBtn.addEventListener('click', exportJSON);

    // ---------- Helpers ----------
    function showStatus(msg, type='info') {
      lastMsg.textContent = msg;
      if (type === 'error') {
        connBadge.className = 'inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm bg-red-100 text-red-800';
      } else if (type === 'success') {
        connBadge.className = 'inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm bg-green-100 text-green-800';
      } else {
        connBadge.className = 'inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm bg-yellow-100 text-yellow-800';
      }
    }

    function setConnected(flag) {
      state.connected = flag;
      if (flag) {
        connBadge.textContent = 'Connected';
        refreshBtn.classList.remove('hidden');
        addBtn.classList.remove('hidden');
        showStatus('', 'success');
      } else {
        connBadge.textContent = 'Not connected';
        refreshBtn.classList.add('hidden');
        addBtn.classList.add('hidden');
      }
    }

    function clearModal() { document.getElementById('modalRoot').innerHTML = ''; }

    function buildHeaders(isWrite=false) {
      const headers = new Headers();
      headers.append('Accept', 'application/json');
      // Add Authorization header if tokens provided (both styles)
      if (state.readToken) {
        headers.append('Authorization', 'Bearer ' + state.readToken);
        headers.append('x-read-token', state.readToken);
      }
      if (isWrite && state.writeToken) {
        // If write op, prefer writeToken for Authorization
        headers.set('Authorization', 'Bearer ' + state.writeToken);
        headers.set('x-write-token', state.writeToken);
      }
      return headers;
    }

    function apiUrl(path) {
      const base = state.baseUrl || document.getElementById('baseUrl').value.trim();
      // ensure trailing slash removed
      return base.replace(/\/+$/,'') + '/' + path.replace(/^\/+/,'');
    }

    async function safeFetch(url, opts={}) {
      // wrapper for fetch with timeout and friendly errors
      try {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), 20000);
        opts.signal = controller.signal;
        const res = await fetch(url, opts);
        clearTimeout(id);
        // attempt to parse JSON safely
        const text = await res.text();
        let body = null;
        try { body = text ? JSON.parse(text) : null; } catch(e) { body = text; }
        if (!res.ok) throw { status: res.status, body };
        return { ok: true, status: res.status, body };
      } catch (err) {
        if (err.name === 'AbortError') throw new Error('Request timed out');
        if (err.status) throw new Error(`HTTP ${err.status}: ${JSON.stringify(err.body)}`);
        throw err;
      }
    }

    // ---------- API actions ----------
    async function onConnect() {
      // update tokens and baseUrl from inputs
      state.baseUrl = document.getElementById('baseUrl').value.trim();
      state.readToken = document.getElementById('readToken').value;
      state.writeToken = document.getElementById('writeToken').value;

      if (!state.baseUrl) { showStatus('Enter API Base URL first', 'error'); return; }
      if (!state.readToken) { showStatus('Enter Read Token', 'error'); return; }
      // We allow connecting with only read token — but warn if write token missing for write ops.
      setConnected(true);
      showStatus('Connected (read-only mode if no write token provided)', state.writeToken ? 'success' : 'info');
    }

    function onClearAll() {
      document.getElementById('readToken').value = '';
      document.getElementById('writeToken').value = '';
      document.getElementById('baseUrl').value = '';
      state = { baseUrl: '', readToken: '', writeToken: '', connected: false, service: '', instance: '', configs: [] };
      setConnected(false);
      renderConfigs([]);
      showStatus('Cleared', 'info');
    }

    async function loadConfigs() {
      if (!state.connected) { showStatus('Not connected — click Connect', 'error'); return; }
      const service = state.service || serviceInput.value.trim();
      const instance = state.instance || instanceInput.value.trim();
      if (!service || !instance) { showStatus('Set both Service and Instance', 'error'); return; }

      const url = apiUrl('list') + '?service=' + encodeURIComponent(service) + '&instance=' + encodeURIComponent(instance);
      showStatus('Loading configs...');
      try {
        const res = await safeFetch(url, { method: 'GET', headers: buildHeaders(false) });
        // Expect response body to be either array or object. Normalize.
        let data = res.body;
        if (!data) data = [];
        // if object with keys, convert
        if (!Array.isArray(data) && typeof data === 'object') {
          // assume { key: value } map
          const arr = Object.entries(data).map(([k,v]) => ({ key:k, value: v }));
          data = arr;
        }
        // store state
        state.service = service;
        state.instance = instance;
        state.configs = data.map(item => {
          return { key: item.key ?? item.name ?? item.k ?? '', value: item.value ?? item.val ?? item.v ?? item };
        });
        renderConfigs(state.configs);
        showStatus(`Loaded ${state.configs.length} config(s)`, 'success');
      } catch (err) {
        showStatus(String(err), 'error');
      }
    }

    function renderConfigsFiltered() {
      const q = searchInput.value.trim().toLowerCase();
      const filtered = state.configs.filter(c => c.key.toLowerCase().includes(q));
      renderConfigs(filtered);
    }

    function renderConfigs(list) {
      configsTbody.innerHTML = '';
      if (!list || list.length === 0) {
        configsTbody.appendChild(emptyRow);
        return;
      }
      list.forEach(entry => {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-gray-50';
        const tdKey = document.createElement('td');
        tdKey.className = 'px-4 py-3 mono text-sm';
        tdKey.textContent = entry.key;

        const tdVal = document.createElement('td');
        tdVal.className = 'px-4 py-3 text-sm text-gray-700';
        // preview: attempt JSON pretty snippet
        let preview = '';
        const v = entry.value;
        try {
          if (typeof v === 'object') preview = JSON.stringify(v).slice(0, 120);
          else preview = String(v).slice(0,120);
        } catch (e) {
          preview = String(v).slice(0,120);
        }
        tdVal.textContent = preview + (String(preview).length >= 120 ? '…' : '');

        const tdActions = document.createElement('td');
        tdActions.className = 'px-4 py-3';

        const viewBtn = document.createElement('button');
        viewBtn.className = 'mr-2 px-3 py-1 rounded border text-sm';
        viewBtn.textContent = 'View';
        viewBtn.addEventListener('click', () => openEditModal({ key: entry.key, value: entry.value, isNew: false }));

        const delBtn = document.createElement('button');
        delBtn.className = 'px-3 py-1 rounded border text-sm text-red-600';
        delBtn.textContent = 'Delete';
        delBtn.addEventListener('click', () => confirmDelete(entry.key));

        tdActions.appendChild(viewBtn);
        tdActions.appendChild(delBtn);

        tr.appendChild(tdKey);
        tr.appendChild(tdVal);
        tr.appendChild(tdActions);
        configsTbody.appendChild(tr);
      });
    }

    // ---------- Modal for view/edit/add ----------
    function openEditModal({ key = '', value = '', isNew = false } = {}) {
      const modalRoot = document.getElementById('modalRoot');
      const prettyValue = tryPretty(value);

      modalRoot.innerHTML = `
      <div class="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
        <div class="w-full max-w-3xl bg-white rounded shadow-lg overflow-hidden">
          <div class="p-4 border-b flex items-center justify-between">
            <div>
              <h3 class="text-lg font-medium">${isNew ? 'Add new config' : 'View / Edit config'}</h3>
              <p class="text-xs text-gray-500 mt-1">${isNew ? 'Create a new key/value pair' : 'Edit the value and click Save'}</p>
            </div>
            <div>
              <button id="closeModalBtn" class="px-3 py-1 rounded border">Close</button>
            </div>
          </div>
          <div class="p-4 space-y-3">
            <label class="text-xs text-gray-600">Key</label>
            <input id="modalKey" class="w-full border rounded px-2 py-2 mono" value="${escapeHtml(key)}" ${isNew ? '' : 'readonly'} />
            <label class="text-xs text-gray-600">Value (JSON or text)</label>
            <textarea id="modalValue" rows="10" class="w-full border rounded px-2 py-2 mono">${escapeHtml(prettyValue)}</textarea>
            <div class="flex items-center gap-2">
              <button id="saveModalBtn" class="bg-indigo-600 text-white px-4 py-2 rounded">${isNew ? 'Create' : 'Save'}</button>
              ${isNew ? '' : '<button id="refreshValueBtn" class="border px-3 py-2 rounded">Reload Value</button>'}
              <div id="modalMsg" class="text-sm text-gray-500"></div>
            </div>
          </div>
        </div>
      </div>
      `;

      document.getElementById('closeModalBtn').addEventListener('click', () => { clearModal(); });
      document.getElementById('saveModalBtn').addEventListener('click', async () => {
        const k = document.getElementById('modalKey').value.trim();
        const raw = document.getElementById('modalValue').value;
        if (!k) return updateModalMsg('Key required', 'error');
        await saveConfig(k, raw, isNew);
      });
      if (!isNew) {
        document.getElementById('refreshValueBtn').addEventListener('click', async () => {
          const k = document.getElementById('modalKey').value.trim();
          await reloadSingleValue(k);
        });
      }
    }

    function updateModalMsg(msg, type='info') {
      const el = document.getElementById('modalMsg');
      if (!el) return;
      el.textContent = msg;
      el.className = 'text-sm ' + (type === 'error' ? 'text-red-600' : 'text-gray-500');
    }

    function escapeHtml(s) {
      if (s === null || s === undefined) return '';
      return String(s)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;');
    }

    function tryPretty(v) {
      if (v === null || v === undefined) return '';
      try {
        if (typeof v === 'string') {
          // try parse as JSON then pretty
          const parsed = JSON.parse(v);
          return JSON.stringify(parsed, null, 2);
        } else if (typeof v === 'object') {
          return JSON.stringify(v, null, 2);
        } else {
          return String(v);
        }
      } catch (e) {
        // not JSON
        return String(v);
      }
    }

    // ---------- CRUD ----------
    async function saveConfig(key, rawValue, isNew=false) {
      if (!state.connected) { updateModalMsg('Not connected', 'error'); return; }
      const service = state.service || serviceInput.value.trim();
      const instance = state.instance || instanceInput.value.trim();
      if (!service || !instance) { updateModalMsg('Set both Service and Instance first', 'error'); return; }

      // try to parse JSON for proper type; if fails, send as string
      let finalValue = rawValue;
      try {
        finalValue = JSON.parse(rawValue);
      } catch (e) {
        // keep as string
        finalValue = rawValue;
      }

      const url = apiUrl('set');
      const body = { service, instance, key, value: finalValue };
      updateModalMsg('Saving...');
      try {
        const res = await safeFetch(url, {
          method: 'POST',
          headers: (() => {
            const h = buildHeaders(true);
            h.set('Content-Type','application/json');
            return h;
          })(),
          body: JSON.stringify(body)
        });
        // update local cache if success
        // replace or push
        const existing = state.configs.find(c => c.key === key);
        if (existing) existing.value = finalValue;
        else state.configs.unshift({ key, value: finalValue });
        renderConfigs(state.configs);
        updateModalMsg('Saved successfully', 'success');
        // close modal after short delay
        setTimeout(() => clearModal(), 700);
        showStatus('Saved', 'success');
      } catch (err) {
        updateModalMsg('Save failed: ' + String(err), 'error');
      }
    }

    async function reloadSingleValue(key) {
      if (!state.connected) return updateModalMsg('Not connected', 'error');
      const service = state.service || serviceInput.value.trim();
      const instance = state.instance || instanceInput.value.trim();
      const url = apiUrl('get') + '?service=' + encodeURIComponent(service) + '&instance=' + encodeURIComponent(instance) + '&key=' + encodeURIComponent(key);
      updateModalMsg('Reloading...');
      try {
        const res = await safeFetch(url, { method: 'GET', headers: buildHeaders(false) });
        const v = res.body;
        const pretty = tryPretty(v);
        const ta = document.getElementById('modalValue');
        if (ta) ta.value = pretty;
        updateModalMsg('Reloaded', 'success');
        // update local state
        const existing = state.configs.find(c => c.key === key);
        if (existing) existing.value = v;
        renderConfigs(state.configs);
      } catch (err) {
        updateModalMsg('Reload failed: ' + String(err), 'error');
      }
    }

    async function confirmDelete(key) {
      if (!confirm(`Delete config key "${key}" in service "${state.service}" instance "${state.instance}"?`)) return;
      await deleteConfig(key);
    }

    async function deleteConfig(key) {
      if (!state.connected) { showStatus('Not connected', 'error'); return; }
      const service = state.service || serviceInput.value.trim();
      const instance = state.instance || instanceInput.value.trim();
      const url = apiUrl('delete') + '?service=' + encodeURIComponent(service) + '&instance=' + encodeURIComponent(instance) + '&key=' + encodeURIComponent(key);
      showStatus('Deleting...');
      try {
        const res = await safeFetch(url, { method: 'DELETE', headers: buildHeaders(true) });
        // remove from UI
        state.configs = state.configs.filter(c => c.key !== key);
        renderConfigs(state.configs);
        showStatus(`Deleted ${key}`, 'success');
      } catch (err) {
        showStatus('Delete failed: ' + String(err), 'error');
      }
    }

    function exportJSON() {
      const blob = new Blob([JSON.stringify({ service: state.service, instance: state.instance, configs: state.configs }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `dccc-${state.service || 'service'}-${state.instance || 'instance'}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------- Init ----------
    setConnected(false);
    renderConfigs([]);

    // Optional: attempt to prefill baseUrl if not changed by user (already set)
  </script>
</body>
</html>
